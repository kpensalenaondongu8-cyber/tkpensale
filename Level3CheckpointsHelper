FIRST WORD


## **Breaking Down the Solution Pattern**

Let me show you ONE way to think about it, then you'll write your version:

### **Step-by-Step Logic:**
```
STEP 1: Handle edge case
  - If string is empty, return just "\n"

STEP 2: Find where the first word STARTS

Declare an empty string that would hold the result
  - Use a position tracker (let's call it 'i')
  - While i is less than string length AND character at i is a space
    - Move i forward (i++)
  - Now i points to the first non-space character (or end of string)

STEP 3: Find where the first word ENDS
  - Start collecting from position i
  - While i is less than string length AND character at i is NOT a space
    - Add character to result
    - Move i forward
  
STEP 4: Add newline and return





LAST WORD

STEP 1: Handle edge case
  - If string is empty, return just "\n"

STEP 2: Find where the last word ENDS
  - Declare a variable to track position (let's call it 'i')
  - Set i to the last index of the string (len(s) - 1)
  - While i is greater than or equal to 0 AND character at i is a space
    - Move i backward (i--)
  - Now i points to the last non-space character (or -1 if all spaces)
  
STEP 2.5: Check if we found any word
  - If i is less than 0 (meaning string was all spaces)
    - Return just "\n"

STEP 3: Find where the last word STARTS and collect it
  Option A (Using string slicing - RECOMMENDED):
    - Remember the END position (let's call it 'end' = i)
    - While i is greater than or equal to 0 AND character at i is NOT a space
      - Move i backward (i--)
    - Now i is ON the space before the word (or at -1 if word starts at beginning)
    - Adjust: set start = i + 1 (to get the first character of the word)
    - Extract the word using slicing: s[start:end+1]
  
  Option B (Using character collection):
    - Declare an empty string that would hold the result
    - While i is greater than or equal to 0 AND character at i is NOT a space
      - Add character to the FRONT of result (result = string(s[i]) + result)
      - Move i backward (i--)
    - Now result contains the last word (correctly ordered)

STEP 4: Add newline and return
  - Return result + "\n"





  CAMELTOSNAKECASE

  STEP 1: Handle edge case
  - If string is empty, return empty string

STEP 2: Initialize variables
  - Create an empty result string to build the output
  - Create a boolean flag 'prevUpper' set to false
    (this tracks if the previous character was uppercase)

STEP 3: Validate and convert the string (single pass)
  - For each character position i and character r in the string:
    
    STEP 3A: Classify the current character
      - Check if character is lowercase (between 'a' and 'z')
      - Check if character is uppercase (between 'A' and 'Z')
    
    STEP 3B: Validate camelCase rules
      - INVALID CASE 1: If character is NOT a letter (not lower AND not upper)
        → Return original string unchanged
      
      - INVALID CASE 2: If current character is uppercase AND previous was also uppercase
        → Return original string unchanged (consecutive uppercase not allowed)
      
      - INVALID CASE 3: If current character is uppercase AND it's the last character
        → Return original string unchanged (can't end with uppercase)
    
    STEP 3C: Convert to snake_case
      - If current character is uppercase AND not at the beginning (i != 0)
        → Add underscore "_" to result
      
      - Add current character to result (as string)
    
    STEP 3D: Update state for next iteration
      - Set prevUpper to whether current character was uppercase
        (this becomes the "previous" for the next iteration)

STEP 4: Return the result
  - Return the converted snake_case string



  SEARCH AND REPLACE

  STEP 1: Check number of arguments
  - If len(os.Args) is NOT equal to 4 (program name + 3 args)
    → Exit program (print nothing)

STEP 2: Extract the arguments
  - Get the source string (os.Args[1])
  - Get the old character (os.Args[2])
  - Get the new character (os.Args[3])

STEP 3: Validate old character
  - old must be exactly 1 character long
  - If not, exit (or handle edge case)

STEP 4: Build the result string
  - Create an empty result string
  - For each character in the source string:
    - If character equals old character
      → Add new character to result
    - Else
      → Add original character to result

STEP 5: Output
  - Print result + newline
```


REPEATALPHA

FUNCTION RepeatAlpha(s: string) RETURNS string

  // STEP 1: Edge case validation
  IF s is empty THEN
    RETURN ""
  END IF

  // STEP 2: Initialize accumulator
  result = "" (empty string)

  // STEP 3: Main processing loop
  FOR EACH character c IN string s DO
    
    // STEP 3A: Declare position variable
    DECLARE position as integer
    
    // STEP 3B: Calculate alphabetical position
    IF c >= 'a' AND c <= 'z' THEN
      // Lowercase letter
      position = integer(c - 'a' + 1)
    
    ELSE IF c >= 'A' AND c <= 'Z' THEN
      // Uppercase letter
      position = integer(c - 'A' + 1)
    
    ELSE
      // Non-alphabetic character (space, digit, punctuation)
      position = 1
    
    END IF
    
    // STEP 3C: Repeat character 'position' times
    FOR i FROM 0 TO position-1 DO
      result = result + string(c)
    END FOR
  
  END FOR

  // STEP 4: Return final result
  RETURN result

END FUNCTION